package vulnerability

import (
	"fmt"
	"sync"

	"scanco/pkg/scanner"
)

// Scanner is the main vulnerability scanner that coordinates
type Scanner struct {
	sources []VulnerabilitySource
}

// NewScanner creates a new vulnerability scanner with the given sources
func NewScanner(sources ...VulnerabilitySource) *Scanner {
	return &Scanner{
		sources: sources,
	}
}

// ScanPackages scans a list of packages for vulnerabilities across all sources
func (s *Scanner) ScanPackages(packages []scanner.Package, options *ScanOptions) (*ScanResult, error) {
	if options == nil {
		options = DefaultScanOptions()
	}

	var results []VulnerabilityResult
	var resultsMu sync.Mutex
	var wg sync.WaitGroup
	errCh := make(chan error, len(packages)*len(s.sources))

	// For quick scan, only process first few packages
	packagesToScan := packages
	if options.QuickScan {
		endIdx := min(options.PageSize, len(packages))
		packagesToScan = packages[:endIdx]
	}

	// For each package, check all vulnerability sources
	for _, pkg := range packagesToScan {
		wg.Add(1)
		go func(p scanner.Package) {
			defer wg.Done()

			// Query each source for vulnerabilities
			for _, source := range s.sources {
				vulns, err := source.GetVulnerabilities(p, options)
				if err != nil {
					errCh <- fmt.Errorf("error from %s scanning %s: %w", source.Name(), p.Name, err)
					continue
				}

				// Convert vulnerabilities to results
				var pkgResults []VulnerabilityResult
				for _, vuln := range vulns {
					pkgResults = append(pkgResults, VulnerabilityResult{
						Package:       p,
						Vulnerability: vuln,
					})
				}

				// Add results under lock
				resultsMu.Lock()
				results = append(results, pkgResults...)
				resultsMu.Unlock()
			}
		}(pkg)
	}

	// Wait for all scans to complete
	wg.Wait()
	close(errCh)

	// Collect any errors
	var errs []error
	for err := range errCh {
		errs = append(errs, err)
	}

	// Filter results by severity
	results = s.FilterResults(results, options.MinSeverity)

	// Calculate pagination
	totalResults := len(results)
	startIdx := (options.PageNumber - 1) * options.PageSize
	endIdx := min(startIdx+options.PageSize, totalResults)

	// Ensure valid range
	if startIdx >= totalResults {
		startIdx = 0
		endIdx = 0
	}

	// Create scan result
	scanResult := &ScanResult{
		Results:      results[startIdx:endIdx],
		TotalResults: totalResults,
		CurrentPage:  options.PageNumber,
		HasMorePages: endIdx < totalResults,
		PackagesLeft: len(packages) - len(packagesToScan),
		QuickScan:    options.QuickScan,
	}

	// If we have any results, return them even if there were some errors
	if len(results) > 0 {
		if len(errs) > 0 {
			// Log errors but don't fail if we have partial results
			for _, err := range errs {
				fmt.Printf("Warning: %v\n", err)
			}
		}
		return scanResult, nil
	}

	// If we have no results and errors occurred, return the first error
	if len(errs) > 0 {
		return nil, errs[0]
	}

	return scanResult, nil
}

// FilterResults filters vulnerability results based on severity
func (s *Scanner) FilterResults(results []VulnerabilityResult, minSeverity Severity) []VulnerabilityResult {
	// Define severity levels for comparison
	severityLevels := map[Severity]int{
		SeverityCritical: 4,
		SeverityHigh:     3,
		SeverityMedium:   2,
		SeverityLow:      1,
		SeverityNone:     0,
	}

	minLevel := severityLevels[minSeverity]
	var filtered []VulnerabilityResult

	for _, result := range results {
		if level := severityLevels[result.Vulnerability.Severity]; level >= minLevel {
			filtered = append(filtered, result)
		}
	}

	return filtered
}

// GroupResultsByPackage groups vulnerability results by package
func (s *Scanner) GroupResultsByPackage(results []VulnerabilityResult) map[string][]VulnerabilityResult {
	grouped := make(map[string][]VulnerabilityResult)

	for _, result := range results {
		key := fmt.Sprintf("%s@%s", result.Package.Name, result.Package.Version)
		grouped[key] = append(grouped[key], result)
	}

	return grouped
}

// min returns the smaller of x or y
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
