package nvd

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"golang.org/x/time/rate"

	"scanco/pkg/scanner"
	"scanco/pkg/vulnerability"
	"scanco/pkg/vulnerability/version"
)

// Client represents an NVD API client
type Client struct {
	config      *Config
	httpClient  *http.Client
	rateLimiter *rate.Limiter
	lastRequest time.Time
	matcher     map[string]*version.Matcher // Version matchers for each ecosystem
}

// NewClient creates a new NVD API client
func NewClient(config *Config) *Client {
	if config == nil {
		config = DefaultConfig()
	}

	// Create rate limiter based on API key presence
	var limiter *rate.Limiter
	if config.APIKey != "" {
		// With API key: 50 calls per 30 seconds
		limiter = rate.NewLimiter(rate.Every(30*time.Second/50), 1)
	} else {
		// Without API key: 10 calls per minute
		limiter = rate.NewLimiter(rate.Every(config.RateLimit), 1)
	}

	// Initialize version matchers for each supported ecosystem
	matchers := map[string]*version.Matcher{
		"apk": version.NewMatcher("apk"),
		"apt": version.NewMatcher("apt"),
	}

	return &Client{
		config:      config,
		httpClient:  &http.Client{Timeout: time.Second * 30},
		rateLimiter: limiter,
		matcher:     matchers,
	}
}

// GetVulnerabilities implements the VulnerabilitySource interface
func (c *Client) GetVulnerabilities(pkg scanner.Package, options *vulnerability.ScanOptions) ([]vulnerability.Vulnerability, error) {
	if options == nil {
		options = vulnerability.DefaultScanOptions()
	}

	// Build query parameters for NVD API v2.0
	query := url.Values{}

	// Use keyword search for package name
	query.Add("keywordSearch", pkg.Name)

	// Add pagination parameters
	query.Add("startIndex", fmt.Sprintf("%d", (options.PageNumber-1)*options.PageSize))
	query.Add("resultsPerPage", fmt.Sprintf("%d", options.PageSize))

	vulns, err := c.searchVulnerabilities(context.Background(), query)
	if err != nil {
		return nil, fmt.Errorf("searching vulnerabilities: %w", err)
	}

	var results []vulnerability.Vulnerability
	var versionErrors []error

	for _, v := range vulns {
		vuln := c.convertCVE(v.Cve)
		if vuln == nil {
			continue
		}

		affected, err := c.isPackageAffected(pkg, v.Cve)
		if err != nil {
			versionErrors = append(versionErrors, fmt.Errorf("checking version for %s: %w", pkg.Name, err))
			continue
		}

		if affected {
			results = append(results, *vuln)
		}

		if options.QuickScan && len(results) >= options.PageSize {
			break
		}
	}

	// If we found no vulnerabilities but had version errors, return the first error
	if len(results) == 0 && len(versionErrors) > 0 {
		return nil, versionErrors[0]
	}

	return results, nil
}

// isPackageAffected checks if a package is affected by a CVE based on version constraints
func (c *Client) isPackageAffected(pkg scanner.Package, cve CVE) (bool, error) {
	matcher, ok := c.matcher[pkg.Source]
	if !ok {
		return false, fmt.Errorf("unsupported package source: %s", pkg.Source)
	}

	// Check each configuration node
	for _, config := range cve.Configurations {
		for _, node := range config.Nodes {
			for _, cpeMatch := range node.CPEMatch {
				// Skip if not vulnerable
				if !cpeMatch.Vulnerable {
					continue
				}

				// Check if the CPE matches the package name
				if !cpeMatchesPackage(cpeMatch.Criteria, pkg.Name) {
					continue
				}

				// Build version constraint string
				var constraints []string

				if cpeMatch.VersionStartIncluding != "" {
					constraints = append(constraints, fmt.Sprintf(">= %s", cpeMatch.VersionStartIncluding))
				}
				if cpeMatch.VersionStartExcluding != "" {
					constraints = append(constraints, fmt.Sprintf("> %s", cpeMatch.VersionStartExcluding))
				}
				if cpeMatch.VersionEndIncluding != "" {
					constraints = append(constraints, fmt.Sprintf("<= %s", cpeMatch.VersionEndIncluding))
				}
				if cpeMatch.VersionEndExcluding != "" {
					constraints = append(constraints, fmt.Sprintf("< %s", cpeMatch.VersionEndExcluding))
				}

				// If no constraints, assume all versions are affected
				if len(constraints) == 0 {
					return true, nil
				}

				// Check each constraint
				for _, constraint := range constraints {
					affected, err := matcher.IsAffected(pkg.Version, constraint)
					if err != nil {
						return false, fmt.Errorf("checking version constraint %q: %w", constraint, err)
					}
					if affected {
						return true, nil
					}
				}
			}
		}
	}

	return false, nil
}

// Name implements the VulnerabilitySource interface
func (c *Client) Name() string {
	return "NVD"
}

func (c *Client) searchVulnerabilities(ctx context.Context, query url.Values) ([]VulnerabilityItem, error) {
	// Wait for rate limiter
	err := c.rateLimiter.Wait(ctx)
	if err != nil {
		return nil, fmt.Errorf("rate limiter: %w", err)
	}

	// Build request URL
	reqURL := fmt.Sprintf("%s?%s", c.config.BaseURL, query.Encode())

	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	// Add headers
	req.Header.Set("User-Agent", c.config.UserAgent)
	if c.config.APIKey != "" {
		req.Header.Set("apiKey", c.config.APIKey)
	}

	// Make request with retries
	var resp *http.Response
	var lastErr error
	for attempt := 0; attempt <= c.config.MaxRetries; attempt++ {
		resp, err = c.httpClient.Do(req)
		if err != nil {
			lastErr = err
			if attempt < c.config.MaxRetries {
				time.Sleep(time.Second * time.Duration(attempt+1))
				continue
			}
			break
		}

		// Check response status
		if resp.StatusCode == http.StatusTooManyRequests {
			resp.Body.Close()
			retryAfter := resp.Header.Get("Retry-After")
			if retryAfter != "" {
				seconds, parseErr := time.ParseDuration(retryAfter + "s")
				if parseErr == nil {
					time.Sleep(seconds)
					continue
				}
			}
			time.Sleep(time.Second * time.Duration(attempt+1))
			continue
		}

		// Break on success or non-retryable errors
		break
	}

	if err != nil {
		return nil, fmt.Errorf("making request after %d retries: %w", c.config.MaxRetries, lastErr)
	}
	defer resp.Body.Close()

	// Read response body for error reporting
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response into CVEResponse structure
	var cveResp CVEResponse
	if err := json.Unmarshal(body, &cveResp); err != nil {
		return nil, fmt.Errorf("parsing response JSON: %w", err)
	}

	return cveResp.Vulnerabilities, nil
}

func (c *Client) convertCVE(cve CVE) *vulnerability.Vulnerability {
	// Get the highest CVSS score and severity
	var score float64
	var severity string

	// Check CVSS 3.1 first
	if len(cve.Metrics.CVSSMetricV31) > 0 {
		score = cve.Metrics.CVSSMetricV31[0].Score
		severity = cve.Metrics.CVSSMetricV31[0].Severity
	} else if len(cve.Metrics.CVSSMetricV30) > 0 {
		// Fall back to CVSS 3.0
		score = cve.Metrics.CVSSMetricV30[0].Score
		severity = cve.Metrics.CVSSMetricV30[0].Severity
	} else if len(cve.Metrics.CVSSMetricV2) > 0 {
		// Fall back to CVSS 2.0
		score = cve.Metrics.CVSSMetricV2[0].Score
		severity = cve.Metrics.CVSSMetricV2[0].Severity
	}

	// Get English description
	var description string
	for _, desc := range cve.Descriptions {
		if desc.Lang == "en" {
			description = desc.Value
			break
		}
	}

	// Convert references
	var references []string
	for _, ref := range cve.References {
		references = append(references, ref.URL)
	}

	return &vulnerability.Vulnerability{
		ID:          cve.ID,
		Title:       description, // Using description as title for now
		Description: description,
		Severity:    vulnerability.Severity(severity),
		CVSS:        score,
		Published:   cve.Published.Time,
		Updated:     cve.LastModified.Time,
		References:  references,
	}
}
 